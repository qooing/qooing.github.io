[{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01-copy/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n[이미지 - 거북이와 로켓의 경주] (추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"vite.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e[이미지 - 거북이와 로켓의 경주]\u003c/strong\u003e\n\u003cem\u003e(추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n[이미지 - 거북이와 로켓의 경주] (추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"vite.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e[이미지 - 거북이와 로켓의 경주]\u003c/strong\u003e\n\u003cem\u003e(추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n[이미지 - 거북이와 로켓의 경주] (추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"vite.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e[이미지 - 거북이와 로켓의 경주]\u003c/strong\u003e\n\u003cem\u003e(추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n[이미지 - 거북이와 로켓의 경주] (추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"vite.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e[이미지 - 거북이와 로켓의 경주]\u003c/strong\u003e\n\u003cem\u003e(추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n[이미지 - 거북이와 로켓의 경주] (추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"vite.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e[이미지 - 거북이와 로켓의 경주]\u003c/strong\u003e\n\u003cem\u003e(추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n[이미지 - 거북이와 로켓의 경주] (추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e[이미지 - 거북이와 로켓의 경주]\u003c/strong\u003e\n\u003cem\u003e(추천 이미지: 느릿느릿한 과거의 도구(CRA)를 제치고 엄청난 속도로 날아가는 로켓(Vite) 일러스트. 빠르고 경쾌한 느낌을 주는 이미지)\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 **Vite(비트)**라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v18.17.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 **LTS 버전(안정적이고 가장 많이 쓰이는 버전)**을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 **VS Code(Visual Studio Code)**를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다.\n[이미지 - VS Code 확장 프로그램 탭 화면] (설명: VS Code 좌측의 확장 프로그램(블록 모양) 아이콘을 클릭하고 검색창에 아래 플러그인들을 검색하는 스크린샷)\nPrettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n[이미지 - 브라우저에 Vite + React 로고가 떠 있는 실행 성공 화면] (설명: 어두운 배경에 Vite 로고와 React 로고가 크게 떠 있고 가운데에 카운터 버튼이 있는 기본 템플릿 화면)\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 **저장(Ctrl + S)**을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요! 궁금한 점이 있다면 언제든 댓글 남겨주시면 Qooing이 답변해 드리겠습니다.\nQooing님, 2편 원고를 새로 다듬어 보았습니다. 오해를 살 만한 링크 양식을 빼고 자연스럽게 다음 화를 예고하는 방식으로 마무리했습니다.\n이 내용으로 블로깅을 진행하실지, 아니면 이어서 3편(JSX 문법 실습) 원고 작성을 바로 도와드릴까요?\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"\n안녕하세요, Qooing입니다! 👋\n지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다. 이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 위한 작업실을 꾸며보겠습니다.\n\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo; 걱정 마세요. 오늘 소개할 Vite(비트) 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\n1. 프론트엔드 개발의 엔진: Node.js 설치 리액트 개발을 하려면 가장 먼저 Node.js가 컴퓨터에 깔려 있어야 합니다. \u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\n리액트는 우리가 작성한 코드를 브라우저가 이해할 수 있도록 압축하고, 변환하고, 하나로 묶어주는 작업(빌드)이 필요합니다. 이 복잡한 공장을 돌려주는 \u0026lsquo;엔진\u0026rsquo; 역할을 Node.js가 해주기 때문입니다.\n🛠️ 설치 및 확인 방법 터미널(Mac은 Terminal, Windows는 명령 프롬프트나 PowerShell)을 엽니다. 아래 명령어를 입력해 보세요. 1 node -v v24.13.0 처럼 버전 숫자가 나온다면 이미 설치되어 있는 것입니다. 통과! 만약 \u0026ldquo;명령어를 찾을 수 없습니다\u0026quot;라는 에러가 뜬다면, Node.js 공식 홈페이지에 접속하여 LTS 버전(안정적이고 가장 많이 쓰이는 버전) 을 다운로드해 설치해 주세요. 2. 생산성 200% 향상: VS Code 확장 프로그램 세팅 본격적인 프로젝트 생성에 앞서, 우리의 주력 무기인 VS Code(Visual Studio Code) 를 튜닝해 보겠습니다. 이 두 가지만 설치해도 코딩이 훨씬 즐거워집니다. Prettier - Code formatter: 띄어쓰기, 줄바꿈 등 코드를 저장할 때마다 아주 예쁘게 자동 정렬해 줍니다. (필수 중의 필수!) ES7+ React/Redux/React-Native snippets: rfce라는 마법의 단어 네 글자만 치면, 리액트 컴포넌트의 기본 뼈대를 1초 만에 자동으로 완성해 주는 도구입니다. 3. 프로젝트 생성: 왜 CRA 대신 Vite인가? 예전에는 리액트를 시작할 때 Create React App (CRA)이라는 도구를 썼습니다. 하지만 프로젝트 덩치가 커지면 서버를 켜는 데만 수십 초가 걸리는 치명적인 단점이 있었죠.\n그래서 최근에는 프랑스어로 \u0026lsquo;빠르다\u0026rsquo;는 뜻을 가진 Vite가 대세로 자리 잡았습니다. 정말 빛의 속도로 켜집니다.\n🛠️ 5분 만에 프로젝트 띄우기 터미널을 열고, 프로젝트를 만들고 싶은 폴더(예: 바탕화면)로 이동한 뒤 아래 명령어를 차례대로 입력하세요.\n1 2 3 4 5 6 7 8 9 10 11 # 1. \u0026#39;todo-app\u0026#39;이라는 이름의 리액트 프로젝트를 생성합니다. npm create vite@latest todo-app -- --template react # 2. 방금 만든 프로젝트 폴더 안으로 이동합니다. cd todo-app # 3. 프로젝트 구동에 필요한 부품(의존성 패키지)들을 설치합니다. npm install # 4. 드디어 개발 서버를 실행합니다! npm run dev 💡 명령어 해설 npm install을 치면 node_modules라는 엄청나게 무거운 폴더가 생깁니다. 이건 리액트가 돌아가는 데 필요한 외부 도서관(라이브러리)들을 몽땅 다운받아 온 것입니다. 터미널에 http://localhost:5173/ 이라는 로컬 주소가 뜨면 성공입니다! Ctrl (또는 Cmd) 키를 누른 채로 해당 주소를 클릭해 보세요.\n4. 폴더 구조 파헤치기 \u0026amp; 첫 코드 수정 VS Code로 우리가 만든 todo-app 폴더를 열어보세요. 복잡해 보이지만, 지금은 딱 3가지만 알면 됩니다.\nindex.html: 웹사이트의 뼈대입니다. 여기에 \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;라는 빈 상자가 하나 있는데, 리액트가 그린 모든 화면이 이 상자 안으로 들어갑니다. src/main.jsx: 리액트의 진입점입니다. \u0026ldquo;App이라는 그림을 저 root 상자 안에 그려라!\u0026ldquo;라고 명령을 내리는 곳이죠. src/App.jsx ⭐️ (가장 중요): 우리가 실질적으로 코드를 짜고 화면을 꾸밀 메인 스케치북입니다. 🛠️ 나만의 앱으로 바꿔보기 src/App.jsx 파일을 열어서, 기존 코드를 싹 지우고 아래처럼 작성해 보세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/App.jsx import React from \u0026#39;react\u0026#39;; import \u0026#39;./App.css\u0026#39;; // 기본 스타일 적용 function App() { return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;안녕, 리액트! 🚀\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;오늘부터 Smart To-Do Planner를 만듭니다.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 다른 곳에서 이 컴포넌트를 쓸 수 있게 내보냄 코드를 작성하고 저장(Ctrl + S) 을 누르는 순간! 브라우저를 다시 새로고침할 필요도 없이 화면이 즉시 바뀐 것을 볼 수 있습니다.\n개발자가 코드를 수정하면 즉각적으로 화면에 반영해 주는 기능, 이것이 바로 Vite가 자랑하는 강력한 HMR(Hot Module Replacement) 기능입니다. 코딩할 맛이 나죠?\n🚀 마치며 축하합니다! 완벽한 개발 환경을 세팅하고 나만의 첫 번째 리액트 화면까지 띄우셨습니다.\n오늘 우리는:\nNode.js로 코드를 돌릴 엔진을 준비했고 Vite를 이용해 눈 깜짝할 새에 프로젝트를 세팅했으며 App.jsx를 수정해 화면이 실시간으로 변하는 마법을 경험했습니다. 이제 도화지는 준비되었습니다. 다음 시간에는 리액트만의 독특한 문법, HTML과 자바스크립트의 혼종인 JSX 문법에 대해 완벽하게 파헤쳐 보겠습니다.\n다음 포스팅도 기대해 주세요!\n","permalink":"http://localhost:1313/posts/react/react-tutorial-02/","summary":"\u003cp\u003e\u003cimg alt=\"Vite\" loading=\"lazy\" src=\"/images/react/vite.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e지난 시간에는 \u0026ldquo;리액트가 무엇이고, 왜 써야 하는가?\u0026ldquo;에 대한 근본적인 철학을 알아보았습니다.\n이제 이론은 충분합니다! 오늘부터는 본격적으로 우리가 만들 \u003cstrong\u003e\u0026lsquo;Smart To-Do Planner\u0026rsquo;\u003c/strong\u003e 를 위한 작업실을 꾸며보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;개발 환경 설정\u0026hellip; 듣기만 해도 머리 아픈데요?\u0026rdquo;\n걱정 마세요. 오늘 소개할 \u003cstrong\u003eVite(비트)\u003c/strong\u003e 라는 도구를 사용하면 컵라면이 익기도 전에 모든 세팅이 끝납니다. 자, 터미널을 열고 바로 시작해 볼까요?\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-프론트엔드-개발의-엔진-nodejs-설치\"\u003e1. 프론트엔드 개발의 엔진: Node.js 설치\u003c/h2\u003e\n\u003cp\u003e리액트 개발을 하려면 가장 먼저 \u003cstrong\u003eNode.js\u003c/strong\u003e가 컴퓨터에 깔려 있어야 합니다.\n\u003cem\u003e\u0026ldquo;어? 저는 프론트엔드(화면) 개발을 할 건데, 왜 백엔드(서버) 기술인 Node.js를 깔아야 하죠?\u0026rdquo;\u003c/em\u003e\u003c/p\u003e","title":"[React 정복기 #02] 5분 완성! Vite로 가장 빠른 리액트 개발 환경 구축하기"},{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 \u0026lsquo;Smart To-Do Planner\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 \u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo; 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 \u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo; 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 \u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo; 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 \u0026lsquo;딱 그 부분\u0026rsquo; 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 \u0026lsquo;컴포넌트 기반 개발\u0026rsquo; 입니다. 우리가 앞으로 만들 \u0026lsquo;Smart To-Do Planner\u0026rsquo; 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"/images/react/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 \u0026lsquo;\u003cstrong\u003eSmart To-Do Planner\u003c/strong\u003e\u0026lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"}]