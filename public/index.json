[{"content":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. \u0026ldquo;깜빡임\u0026quot;과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 **SPA(Single Page Application)**이고, 리액트가 가장 잘하는 분야입니다.\n[이미지 - MPA와 SPA의 작동 방식 비교] (설명: 왼쪽에는 MPA(전통적 방식)가 요청마다 HTML 전체를 새로 받아오는 그림, 오른쪽에는 SPA(리액트)가 초기 로딩 후 필요한 데이터(JSON)만 받아와서 화면의 일부분만 갈아 끼우는 그림)\n2. \u0026ldquo;어떻게(How)\u0026rdquo; vs \u0026ldquo;무엇을(What)\u0026rdquo; : 선언형 프로그래밍 리액트를 한마디로 정의하자면 **\u0026lsquo;선언형(Declarative) UI 라이브러리\u0026rsquo;**입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 **DOM(화면 요소)**을 하나하나 직접 건드려야 했습니다. \u0026ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라\u0026hellip;\u0026rdquo;\n하지만 리액트에서는 **\u0026ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘\u0026rdquo;**라고 **결과(State)**만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n[이미지 - 명령형 vs 선언형 개념 비교] (설명: 명령형은 요리사에게 \u0026ldquo;양파 썰고, 불 켜고, 볶아라\u0026quot;고 하나하나 지시하는 모습, 선언형은 \u0026ldquo;볶음밥 하나 주세요\u0026quot;라고 주문만 하면 요리가 나오는 모습으로 비유한 일러스트)\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 \u0026ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\u0026quot;라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById(\u0026#39;btn\u0026#39;); const countDisplay = document.getElementById(\u0026#39;count\u0026#39;); let count = 0; btn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 **데이터(State)**만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u0026lt;div\u0026gt; {/* 화면은 이 데이터(count)를 그대로 보여준다고 \u0026#39;선언\u0026#39;함 */} \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;증가\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 💡 코드 해설 useState(0): count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount: 이 함수를 통해 데이터를 바꾸면, 리액트는 \u0026ldquo;어? 데이터가 변했네?\u0026ldquo;라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제: 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n\u0026ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?\u0026rdquo;\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 **\u0026lsquo;가상 DOM(Virtual DOM)\u0026rsquo;**이라는 천재적인 기술을 도입했습니다.\n[이미지 - 리액트의 가상 DOM 동작 원리 (Diffing \u0026amp; Reconciliation)] (설명: 1. 데이터 변경 발생 -\u0026gt; 2. 가상 DOM에 먼저 그림 -\u0026gt; 3. 이전 가상 DOM과 비교하여 바뀐 부분(Diff) 감지 -\u0026gt; 4. 실제 DOM에 그 부분만 업데이트(Patch) 하는 4단계 흐름도)\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): \u0026ldquo;이전 화면\u0026quot;과 \u0026ldquo;새 화면\u0026quot;을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 **\u0026lsquo;딱 그 부분\u0026rsquo;**만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 **\u0026lsquo;컴포넌트 기반 개발\u0026rsquo;**입니다. 우리가 앞으로 만들 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n[이미지 - To-Do 앱 와이어프레임 구조도] (설명: To-Do 앱 화면을 보여주고, Header(빨간 박스), TodoInput(파란 박스), TodoList(초록 박스), TodoItem(노란 박스) 처럼 각 영역을 박스로 감싸서 컴포넌트 단위로 쪼개진 모습을 시각화한 이미지)\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; {/* 1. 헤더: 제목과 날짜 표시 */} \u0026lt;Header /\u0026gt; {/* 2. 입력창: 할 일 입력 및 추가 */} \u0026lt;TodoInput /\u0026gt; {/* 3. 리스트: 목록 보여주기 */} \u0026lt;TodoList\u0026gt; {/* 4. 아이템: 각각의 할 일들 (반복) */} \u0026lt;TodoItem text=\u0026#34;리액트 공부하기\u0026#34; /\u0026gt; \u0026lt;TodoItem text=\u0026#34;블로그 글 쓰기\u0026#34; /\u0026gt; \u0026lt;/TodoList\u0026gt; \u0026lt;/div\u0026gt; ); } [컴포넌트의 장점]\n가독성: \u0026lt;div\u0026gt; 지옥에서 벗어나, \u0026lt;Header /\u0026gt;, \u0026lt;TodoInput /\u0026gt;처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: \u0026lt;TodoItem /\u0026gt; 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: \u0026ldquo;삭제 버튼 디자인 좀 바꿔주세요\u0026quot;라는 요청이 오면, \u0026lt;TodoItem /\u0026gt; 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 \u0026ldquo;왜 리액트인가\u0026quot;에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, \u0026lsquo;Smart To-Do Planner\u0026rsquo; 프로젝트를 생성해 보겠습니다.\n다음 포스팅: 👉 [React 정복기 #02] 5분 컷! Vite로 완벽한 개발 환경 구축하기 (feat. Node.js)\n기대해 주세요! 궁금한 점이나 이해가 안 되는 부분은 댓글로 남겨주시면 Qooing이 직접 답변해 드립니다.\n","permalink":"http://localhost:1313/posts/react/react-tutorial-01/","summary":"\u003cp\u003e\u003cimg alt=\"복잡한 웹 개발, 리액트로 정리하다\" loading=\"lazy\" src=\"images/spagetti.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, \u003cstrong\u003eQooing\u003c/strong\u003e입니다! 👋\u003c/p\u003e\n\u003cp\u003e오늘부터 본격적으로 \u003cstrong\u003eReact(리액트)\u003c/strong\u003e 시리즈를 연재합니다.\n많은 개발자 지망생이나 주니어 분들이 \u0026ldquo;요즘은 리액트가 필수니까\u0026quot;라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 \u003cstrong\u003e탄생 배경\u003c/strong\u003e과 \u003cstrong\u003e핵심 철학\u003c/strong\u003e을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e우리는 앞으로 **\u0026lsquo;Smart To-Do Planner\u0026rsquo;**라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 \u003cstrong\u003e리액트의 동작 원리\u003c/strong\u003e를 아주 상세하게 파헤쳐 보겠습니다.\u003c/p\u003e","title":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"},{"content":"개요 첫번째 테스트 포스팅입니다.\n코드 예시 (코드 삽입 기능) 1 2 def hello_world(): print(\u0026#34;Hello, Gurum Blog!\u0026#34;) ","permalink":"http://localhost:1313/posts/first-post/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e첫번째 테스트 포스팅입니다.\u003c/p\u003e\n\u003ch2 id=\"코드-예시-코드-삽입-기능\"\u003e코드 예시 (코드 삽입 기능)\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003ehello_world\u003c/span\u003e\u003cspan class=\"p\"\u003e():\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello, Gurum Blog!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Git Commit Convention 가이드"}]