<!doctype html><html lang=ko dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요? | Qooing Tech Blog</title><meta name=keywords content="React,JavaScript,Virtual DOM,Component,Declarative"><meta name=description content="React 시리즈의 첫 시작. 왜 React를 사용해야 하는지, 선언형 UI와 가상 DOM의 개념을 통해 알아봅니다."><meta name=author content="Qooing"><link rel=canonical href=https://qooing.github.io/posts/react/react-tutorial-01/><link crossorigin=anonymous href=/assets/css/stylesheet.31e60b7f1bc299cdaa54419ccd5004d88bb202e09af323dd239a9116eec39642.css integrity="sha256-MeYLfxvCmc2qVEGczVAE2IuyAuCa8yPdI5qRFu7DlkI=" rel="preload stylesheet" as=style><link rel=icon href=https://qooing.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qooing.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qooing.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qooing.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qooing.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://qooing.github.io/posts/react/react-tutorial-01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta name=google-site-verification content="uuTRwt2evHl3qx_T2BZYoJLDhBi_RBN2ueGNSY0L7FE"><script async src="https://www.googletagmanager.com/gtag/js?id=G-P2JW8MZH0F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-P2JW8MZH0F")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-P2JW8MZH0F"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-P2JW8MZH0F")}</script><meta property="og:url" content="https://qooing.github.io/posts/react/react-tutorial-01/"><meta property="og:site_name" content="Qooing Tech Blog"><meta property="og:title" content="[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"><meta property="og:description" content="React 시리즈의 첫 시작. 왜 React를 사용해야 하는지, 선언형 UI와 가상 DOM의 개념을 통해 알아봅니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-12T09:00:00+09:00"><meta property="article:modified_time" content="2026-02-12T09:00:00+09:00"><meta property="article:tag" content="React"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="Virtual DOM"><meta property="article:tag" content="Component"><meta property="article:tag" content="Declarative"><meta name=twitter:card content="summary"><meta name=twitter:title content="[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"><meta name=twitter:description content="React 시리즈의 첫 시작. 왜 React를 사용해야 하는지, 선언형 UI와 가상 DOM의 개념을 통해 알아봅니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?","item":"https://qooing.github.io/posts/react/react-tutorial-01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?","name":"[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?","description":"React 시리즈의 첫 시작. 왜 React를 사용해야 하는지, 선언형 UI와 가상 DOM의 개념을 통해 알아봅니다.","keywords":["React","JavaScript","Virtual DOM","Component","Declarative"],"articleBody":"\n안녕하세요, Qooing입니다! 👋\n오늘부터 본격적으로 React(리액트) 시리즈를 연재합니다. 많은 개발자 지망생이나 주니어 분들이 “요즘은 리액트가 필수니까\"라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 탄생 배경과 핵심 철학을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.\n우리는 앞으로 ‘Smart To-Do Planner‘라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 리액트의 동작 원리를 아주 상세하게 파헤쳐 보겠습니다.\n1. “깜빡임\"과의 전쟁: SPA (Single Page Application) 혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 MPA라고 합니다.)\n하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 SPA (Single Page Application) 이고, 리액트가 가장 잘하는 분야입니다.\n2. “어떻게(How)” vs “무엇을(What)” : 선언형 프로그래밍 리액트를 한마디로 정의하자면 ‘선언형(Declarative) UI 라이브러리’ 입니다.\n기존의 자바스크립트 개발(명령형)은 우리가 DOM(화면 요소) 을 하나하나 직접 건드려야 했습니다. “이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라…”\n하지만 리액트에서는 “데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘” 라고 결과(State) 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.\n💻 코드 비교: 노가다 vs 자동화 백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.\n💀 과거의 방식 (명령형: Vanilla JS) 컴퓨터에게 “이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라\"라고 시시콜콜 명령해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1. HTML 요소를 직접 찾아옵니다. const btn = document.getElementById('btn'); const countDisplay = document.getElementById('count'); let count = 0; btn.addEventListener('click', () =\u003e { // 2. 데이터를 바꿉니다. count++; // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다. // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위) countDisplay.innerText = count; }); ✨ 리액트의 방식 (선언형) 우리는 화면을 조작할 필요가 없습니다. 오직 데이터(State) 만 신경 쓰면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useState } from 'react'; function Counter() { const [count, setCount] = useState(0); // 상태(데이터) 정의 return ( \u003cdiv\u003e {/* 화면은 이 데이터(count)를 그대로 보여준다고 '선언'함 */} \u003cspan\u003e{count}\u003c/span\u003e {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */} \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e증가\u003c/button\u003e \u003c/div\u003e ); } 💡 코드 해설 useState(0) : count라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다. setCount : 이 함수를 통해 데이터를 바꾸면, 리액트는 “어? 데이터가 변했네?“라고 감지하고 화면을 알아서 다시 그립니다. document.getElementById 삭제 : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다. 3. 리액트의 엔진: 가상 DOM (Virtual DOM) 여기서 의문이 생깁니다.\n“데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?”\n맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 ‘가상 DOM(Virtual DOM)’ 이라는 천재적인 기술을 도입했습니다.\n[리액트의 처리 과정]\nRender (가상 화면 그리기): 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!) Diff (비교하기): “이전 화면\"과 “새 화면\"을 비교해서 틀린 그림 찾기를 합니다. Commit (실제 반영하기): 찾아낸 ‘딱 그 부분’ 만 실제 브라우저 화면에 업데이트합니다. 이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.\n4. 컴포넌트(Component): 레고 블록 조립하기 마지막으로 리액트의 강력한 무기는 ‘컴포넌트 기반 개발’ 입니다. 우리가 앞으로 만들 ‘Smart To-Do Planner’ 를 상상해 볼까요?\n하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.\n🛠️ 코드로 미리보는 To-Do 앱 구조 이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // App.jsx (메인 파일) function App() { return ( \u003cdiv className=\"app-container\"\u003e {/* 1. 헤더: 제목과 날짜 표시 */} \u003cHeader /\u003e {/* 2. 입력창: 할 일 입력 및 추가 */} \u003cTodoInput /\u003e {/* 3. 리스트: 목록 보여주기 */} \u003cTodoList\u003e {/* 4. 아이템: 각각의 할 일들 (반복) */} \u003cTodoItem text=\"리액트 공부하기\" /\u003e \u003cTodoItem text=\"블로그 글 쓰기\" /\u003e \u003c/TodoList\u003e \u003c/div\u003e ); } [컴포넌트의 장점]\n가독성: 지옥에서 벗어나, , 처럼 이름만 봐도 무엇인지 알 수 있습니다. 재사용성: 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다. 유지보수: “삭제 버튼 디자인 좀 바꿔주세요\"라는 요청이 오면, 파일 하나만 고치면 모든 리스트에 반영됩니다. 🚀 마치며: 본격적인 여정을 시작해 볼까요? 오늘 내용을 요약해 볼까요?\n리액트는 SPA 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱) 리액트는 선언형 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.) 리액트는 가상 DOM을 사용해 알아서 빠르고 효율적으로 화면을 그립니다. 리액트는 컴포넌트 단위로 쪼개서 개발하므로 유지보수가 쉽습니다. 이제 “왜 리액트인가\"에 대한 의문이 풀리셨나요? 이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, ‘Smart To-Do Planner’ 프로젝트를 생성해 보겠습니다.\n","wordCount":"761","inLanguage":"ko","datePublished":"2026-02-12T09:00:00+09:00","dateModified":"2026-02-12T09:00:00+09:00","author":{"@type":"Person","name":"Qooing"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qooing.github.io/posts/react/react-tutorial-01/"},"publisher":{"@type":"Organization","name":"Qooing Tech Blog","logo":{"@type":"ImageObject","url":"https://qooing.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://qooing.github.io/ accesskey=h title="Qooing Tech Blog (Alt + H)">Qooing Tech Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qooing.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://qooing.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qooing.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qooing.github.io/>홈</a></div><h1 class="post-title entry-hint-parent">[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?</h1><div class=post-description>React 시리즈의 첫 시작. 왜 React를 사용해야 하는지, 선언형 UI와 가상 DOM의 개념을 통해 알아봅니다.</div><div class=post-meta><span title='2026-02-12 09:00:00 +0900 +0900'>2026년 2월 12일</span>&nbsp;·&nbsp;<span>4 분</span>&nbsp;·&nbsp;<span>Qooing</span></div></header><div class=post-content><p><img alt="복잡한 웹 개발, 리액트로 정리하다" loading=lazy src=/images/react/spagetti.png></p><p>안녕하세요, <strong>Qooing</strong>입니다! 👋</p><p>오늘부터 본격적으로 <strong>React(리액트)</strong> 시리즈를 연재합니다.
많은 개발자 지망생이나 주니어 분들이 &ldquo;요즘은 리액트가 필수니까"라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 <strong>탄생 배경</strong>과 <strong>핵심 철학</strong>을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.</p><p>우리는 앞으로 &lsquo;<strong>Smart To-Do Planner</strong>&lsquo;라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 <strong>리액트의 동작 원리</strong>를 아주 상세하게 파헤쳐 보겠습니다.</p><hr><h2 id=1-깜빡임과의-전쟁-spa-single-page-application>1. &ldquo;깜빡임"과의 전쟁: SPA (Single Page Application)<a hidden class=anchor aria-hidden=true href=#1-깜빡임과의-전쟁-spa-single-page-application>#</a></h2><p>혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 <strong>MPA</strong>라고 합니다.)</p><p>하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 <strong>SPA (Single Page Application)</strong> 이고, 리액트가 가장 잘하는 분야입니다.</p><p><img alt="MPA와 SPA의 작동 방식 비교" loading=lazy src=/images/react/mpa-spa.png></p><hr><h2 id=2-어떻게how-vs-무엇을what--선언형-프로그래밍>2. &ldquo;어떻게(How)&rdquo; vs &ldquo;무엇을(What)&rdquo; : 선언형 프로그래밍<a hidden class=anchor aria-hidden=true href=#2-어떻게how-vs-무엇을what--선언형-프로그래밍>#</a></h2><p>리액트를 한마디로 정의하자면 <strong>&lsquo;선언형(Declarative) UI 라이브러리&rsquo;</strong> 입니다.</p><p>기존의 자바스크립트 개발(명령형)은 우리가 <strong>DOM(화면 요소)</strong> 을 하나하나 직접 건드려야 했습니다.
&ldquo;이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라&mldr;&rdquo;</p><p>하지만 리액트에서는 <strong>&ldquo;데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘&rdquo;</strong> 라고 <strong>결과(State)</strong> 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.</p><p><img alt="명령형 vs 선언형 개념 비교" loading=lazy src=/images/react/declarative.png></p><h3 id=-코드-비교-노가다-vs-자동화><strong>💻 코드 비교: 노가다 vs 자동화</strong><a hidden class=anchor aria-hidden=true href=#-코드-비교-노가다-vs-자동화>#</a></h3><p>백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.</p><h4 id=-과거의-방식-명령형-vanilla-js><strong>💀 과거의 방식 (명령형: Vanilla JS)</strong><a hidden class=anchor aria-hidden=true href=#-과거의-방식-명령형-vanilla-js>#</a></h4><p>컴퓨터에게 &ldquo;이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라"라고 시시콜콜 명령해야 합니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 1. HTML 요소를 직접 찾아옵니다.
</span></span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>btn</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;btn&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>countDisplay</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;count&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>btn</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;click&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 2. 데이터를 바꿉니다.
</span></span></span><span class=line><span class=cl>  <span class=nx>count</span><span class=o>++</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다.
</span></span></span><span class=line><span class=cl>  <span class=c1>// 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위)
</span></span></span><span class=line><span class=cl>  <span class=nx>countDisplay</span><span class=p>.</span><span class=nx>innerText</span> <span class=o>=</span> <span class=nx>count</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=-리액트의-방식-선언형><strong>✨ 리액트의 방식 (선언형)</strong><a hidden class=anchor aria-hidden=true href=#-리액트의-방식-선언형>#</a></h4><p>우리는 화면을 조작할 필요가 없습니다. 오직 <strong>데이터(State)</strong> 만 신경 쓰면 됩니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>useState</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;react&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Counter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// 상태(데이터) 정의
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=cm>/* 화면은 이 데이터(count)를 그대로 보여준다고 &#39;선언&#39;함 */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>span</span><span class=p>&gt;{</span><span class=nx>count</span><span class=p>}&lt;/</span><span class=nt>span</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=cm>/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)}&gt;</span><span class=nx>증가</span><span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=-코드-해설><strong>💡 코드 해설</strong><a hidden class=anchor aria-hidden=true href=#-코드-해설>#</a></h4><ul><li><strong><code>useState(0)</code></strong> : <code>count</code>라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)**라고 부릅니다.</li><li><strong><code>setCount</code></strong> : 이 함수를 통해 데이터를 바꾸면, 리액트는 &ldquo;어? 데이터가 변했네?&ldquo;라고 감지하고 화면을 <strong>알아서</strong> 다시 그립니다.</li><li><strong><code>document.getElementById</code> 삭제</strong> : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다.</li></ul><hr><h2 id=3-리액트의-엔진-가상-dom-virtual-dom>3. 리액트의 엔진: 가상 DOM (Virtual DOM)<a hidden class=anchor aria-hidden=true href=#3-리액트의-엔진-가상-dom-virtual-dom>#</a></h2><p>여기서 의문이 생깁니다.</p><blockquote><p>&ldquo;데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?&rdquo;</p></blockquote><p>맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 <strong>&lsquo;가상 DOM(Virtual DOM)&rsquo;</strong> 이라는 천재적인 기술을 도입했습니다.</p><p><img alt="리액트의 가상 DOM 동작 원리 (Diffing & Reconciliation)" loading=lazy src=/images/react/virtual-dom.png></p><p><strong>[리액트의 처리 과정]</strong></p><ol><li><strong>Render (가상 화면 그리기):</strong> 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!)</li><li><strong>Diff (비교하기):</strong> &ldquo;이전 화면"과 &ldquo;새 화면"을 비교해서 틀린 그림 찾기를 합니다.</li><li><strong>Commit (실제 반영하기):</strong> 찾아낸 <strong>&lsquo;딱 그 부분&rsquo;</strong> 만 실제 브라우저 화면에 업데이트합니다.</li></ol><p>이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.</p><hr><h2 id=4-컴포넌트component-레고-블록-조립하기>4. 컴포넌트(Component): 레고 블록 조립하기<a hidden class=anchor aria-hidden=true href=#4-컴포넌트component-레고-블록-조립하기>#</a></h2><p>마지막으로 리액트의 강력한 무기는 <strong>&lsquo;컴포넌트 기반 개발&rsquo;</strong> 입니다.
우리가 앞으로 만들 <strong>&lsquo;Smart To-Do Planner&rsquo;</strong> 를 상상해 볼까요?</p><p>하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.</p><p><img alt="To-Do 앱 와이어프레임 구조도" loading=lazy src=/images/react/to-do-template.png></p><h3 id=-코드로-미리보는-to-do-앱-구조><strong>🛠️ 코드로 미리보는 To-Do 앱 구조</strong><a hidden class=anchor aria-hidden=true href=#-코드로-미리보는-to-do-앱-구조>#</a></h3><p>이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=c1>// App.jsx (메인 파일)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span> <span class=na>className</span><span class=o>=</span><span class=s>&#34;app-container&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=cm>/* 1. 헤더: 제목과 날짜 표시 */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>Header</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=cm>/* 2. 입력창: 할 일 입력 및 추가 */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>TodoInput</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=p>{</span><span class=cm>/* 3. 리스트: 목록 보여주기 */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>TodoList</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=cm>/* 4. 아이템: 각각의 할 일들 (반복) */</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>&lt;</span><span class=nt>TodoItem</span> <span class=na>text</span><span class=o>=</span><span class=s>&#34;리액트 공부하기&#34;</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>&lt;</span><span class=nt>TodoItem</span> <span class=na>text</span><span class=o>=</span><span class=s>&#34;블로그 글 쓰기&#34;</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;/</span><span class=nt>TodoList</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>[컴포넌트의 장점]</strong></p><ol><li><strong>가독성:</strong> <code>&lt;div></code> 지옥에서 벗어나, <code>&lt;Header /></code>, <code>&lt;TodoInput /></code>처럼 이름만 봐도 무엇인지 알 수 있습니다.</li><li><strong>재사용성:</strong> <code>&lt;TodoItem /></code> 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다.</li><li><strong>유지보수:</strong> &ldquo;삭제 버튼 디자인 좀 바꿔주세요"라는 요청이 오면, <code>&lt;TodoItem /></code> 파일 하나만 고치면 모든 리스트에 반영됩니다.</li></ol><hr><h2 id=-마치며-본격적인-여정을-시작해-볼까요>🚀 마치며: 본격적인 여정을 시작해 볼까요?<a hidden class=anchor aria-hidden=true href=#-마치며-본격적인-여정을-시작해-볼까요>#</a></h2><p>오늘 내용을 요약해 볼까요?</p><ol><li>리액트는 <strong>SPA</strong> 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱)</li><li>리액트는 <strong>선언형</strong> 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.)</li><li>리액트는 <strong>가상 DOM</strong>을 사용해 알아서 빠르고 효율적으로 화면을 그립니다.</li><li>리액트는 <strong>컴포넌트</strong> 단위로 쪼개서 개발하므로 유지보수가 쉽습니다.</li></ol><p>이제 &ldquo;왜 리액트인가"에 대한 의문이 풀리셨나요?
이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, <strong>&lsquo;Smart To-Do Planner&rsquo;</strong> 프로젝트를 생성해 보겠습니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://qooing.github.io/tags/react/>React</a></li><li><a href=https://qooing.github.io/tags/javascript/>JavaScript</a></li><li><a href=https://qooing.github.io/tags/virtual-dom/>Virtual DOM</a></li><li><a href=https://qooing.github.io/tags/component/>Component</a></li><li><a href=https://qooing.github.io/tags/declarative/>Declarative</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요? on x" href="https://x.com/intent/tweet/?text=%5bReact%20%ec%a0%95%eb%b3%b5%ea%b8%b0%20%2301%5d%20%ed%94%84%eb%a1%a0%ed%8a%b8%ec%97%94%eb%93%9c%ec%9d%98%20%ed%8c%90%eb%8f%84%eb%a5%bc%20%eb%b0%94%ea%be%bc%20React%2c%20%eb%8f%84%eb%8c%80%ec%b2%b4%20%ec%99%9c%20%ec%93%b0%eb%8a%94%20%ea%b1%b8%ea%b9%8c%ec%9a%94%3f&amp;url=https%3a%2f%2fqooing.github.io%2fposts%2freact%2freact-tutorial-01%2f&amp;hashtags=React%2cJavaScript%2cVirtualDOM%2cComponent%2cDeclarative"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fqooing.github.io%2fposts%2freact%2freact-tutorial-01%2f&amp;title=%5bReact%20%ec%a0%95%eb%b3%b5%ea%b8%b0%20%2301%5d%20%ed%94%84%eb%a1%a0%ed%8a%b8%ec%97%94%eb%93%9c%ec%9d%98%20%ed%8c%90%eb%8f%84%eb%a5%bc%20%eb%b0%94%ea%be%bc%20React%2c%20%eb%8f%84%eb%8c%80%ec%b2%b4%20%ec%99%9c%20%ec%93%b0%eb%8a%94%20%ea%b1%b8%ea%b9%8c%ec%9a%94%3f&amp;summary=%5bReact%20%ec%a0%95%eb%b3%b5%ea%b8%b0%20%2301%5d%20%ed%94%84%eb%a1%a0%ed%8a%b8%ec%97%94%eb%93%9c%ec%9d%98%20%ed%8c%90%eb%8f%84%eb%a5%bc%20%eb%b0%94%ea%be%bc%20React%2c%20%eb%8f%84%eb%8c%80%ec%b2%b4%20%ec%99%9c%20%ec%93%b0%eb%8a%94%20%ea%b1%b8%ea%b9%8c%ec%9a%94%3f&amp;source=https%3a%2f%2fqooing.github.io%2fposts%2freact%2freact-tutorial-01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fqooing.github.io%2fposts%2freact%2freact-tutorial-01%2f&title=%5bReact%20%ec%a0%95%eb%b3%b5%ea%b8%b0%20%2301%5d%20%ed%94%84%eb%a1%a0%ed%8a%b8%ec%97%94%eb%93%9c%ec%9d%98%20%ed%8c%90%eb%8f%84%eb%a5%bc%20%eb%b0%94%ea%be%bc%20React%2c%20%eb%8f%84%eb%8c%80%ec%b2%b4%20%ec%99%9c%20%ec%93%b0%eb%8a%94%20%ea%b1%b8%ea%b9%8c%ec%9a%94%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fqooing.github.io%2fposts%2freact%2freact-tutorial-01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요? on whatsapp" href="https://api.whatsapp.com/send?text=%5bReact%20%ec%a0%95%eb%b3%b5%ea%b8%b0%20%2301%5d%20%ed%94%84%eb%a1%a0%ed%8a%b8%ec%97%94%eb%93%9c%ec%9d%98%20%ed%8c%90%eb%8f%84%eb%a5%bc%20%eb%b0%94%ea%be%bc%20React%2c%20%eb%8f%84%eb%8c%80%ec%b2%b4%20%ec%99%9c%20%ec%93%b0%eb%8a%94%20%ea%b1%b8%ea%b9%8c%ec%9a%94%3f%20-%20https%3a%2f%2fqooing.github.io%2fposts%2freact%2freact-tutorial-01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요? on telegram" href="https://telegram.me/share/url?text=%5bReact%20%ec%a0%95%eb%b3%b5%ea%b8%b0%20%2301%5d%20%ed%94%84%eb%a1%a0%ed%8a%b8%ec%97%94%eb%93%9c%ec%9d%98%20%ed%8c%90%eb%8f%84%eb%a5%bc%20%eb%b0%94%ea%be%bc%20React%2c%20%eb%8f%84%eb%8c%80%ec%b2%b4%20%ec%99%9c%20%ec%93%b0%eb%8a%94%20%ea%b1%b8%ea%b9%8c%ec%9a%94%3f&amp;url=https%3a%2f%2fqooing.github.io%2fposts%2freact%2freact-tutorial-01%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요? on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5bReact%20%ec%a0%95%eb%b3%b5%ea%b8%b0%20%2301%5d%20%ed%94%84%eb%a1%a0%ed%8a%b8%ec%97%94%eb%93%9c%ec%9d%98%20%ed%8c%90%eb%8f%84%eb%a5%bc%20%eb%b0%94%ea%be%bc%20React%2c%20%eb%8f%84%eb%8c%80%ec%b2%b4%20%ec%99%9c%20%ec%93%b0%eb%8a%94%20%ea%b1%b8%ea%b9%8c%ec%9a%94%3f&u=https%3a%2f%2fqooing.github.io%2fposts%2freact%2freact-tutorial-01%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://qooing.github.io/>Qooing Tech Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>