---
title: "[React 정복기 #01] 프론트엔드의 판도를 바꾼 React, 도대체 왜 쓰는 걸까요?"
date: 2026-02-13T09:00:00+09:00
draft: false
categories: ["React", "Frontend", "Web Development"]
tags: ["React", "JavaScript", "Virtual DOM", "Component", "Declarative"]
author: "Qooing"
description: "React 시리즈의 첫 시작. 왜 React를 사용해야 하는지, 선언형 UI와 가상 DOM의 개념을 통해 알아봅니다."
---


![복잡한 웹 개발, 리액트로 정리하다](/images/react/spagetti.png)



안녕하세요, **Qooing**입니다! 👋

오늘부터 본격적으로 **React(리액트)** 시리즈를 연재합니다.
많은 개발자 지망생이나 주니어 분들이 "요즘은 리액트가 필수니까"라는 이유로 무작정 문법 공부부터 시작하곤 합니다. 하지만 기술의 **탄생 배경**과 **핵심 철학**을 이해하지 못하면, 나중에 조금만 복잡한 문제에 부딪혀도 길을 잃기 쉽습니다.

우리는 앞으로 '**Smart To-Do Planner**'라는 하나의 완성된 애플리케이션을 바닥부터 만들어갈 예정입니다. 그 대장정을 시작하기 전, 오늘 첫 시간에는 코드를 치기 전에 반드시 알아야 할 **리액트의 동작 원리**를 아주 상세하게 파헤쳐 보겠습니다.

---

## 1. "깜빡임"과의 전쟁: SPA (Single Page Application)

혹시 옛날 웹사이트들을 기억하시나요? 페이지를 이동할 때마다 화면 전체가 하얗게 깜빡이며 새로고침 되곤 했죠. (이걸 **MPA**라고 합니다.)

하지만 요즘 우리가 쓰는 인스타그램이나 노션 같은 앱을 보세요. 버튼을 눌러도 화면이 부드럽게 전환됩니다. 필요한 데이터만 살짝 가져와서 보여주기 때문이죠. 이것이 바로 **SPA (Single Page Application)** 이고, 리액트가 가장 잘하는 분야입니다.

![MPA와 SPA의 작동 방식 비교](/images/react/mpa-spa.png)

---

## 2. "어떻게(How)" vs "무엇을(What)" : 선언형 프로그래밍

리액트를 한마디로 정의하자면 **'선언형(Declarative) UI 라이브러리'** 입니다.

기존의 자바스크립트 개발(명령형)은 우리가 **DOM(화면 요소)** 을 하나하나 직접 건드려야 했습니다.
"이 요소를 찾아서, 기존 내용을 지우고, 빨간색으로 바꾸고, 새 텍스트를 넣어라..."

하지만 리액트에서는 **"데이터가 A 상태면 이 화면, B 상태면 저 화면을 보여줘"** 라고 **결과(State)** 만 정의하면 됩니다. 과정은 리액트가 알아서 합니다.

![명령형 vs 선언형 개념 비교](/images/react/declarative.png)

### **💻 코드 비교: 노가다 vs 자동화**

백문이 불여일견! 버튼을 누르면 숫자가 올라가는 기능을 예로 들어보겠습니다.

#### **💀 과거의 방식 (명령형: Vanilla JS)**

컴퓨터에게 "이 요소를 찾아서, 텍스트를 읽고, 숫자로 바꾸고, 다시 넣어라"라고 시시콜콜 명령해야 합니다.

```javascript
// 1. HTML 요소를 직접 찾아옵니다.
const btn = document.getElementById('btn');
const countDisplay = document.getElementById('count');
let count = 0;

btn.addEventListener('click', () => {
  // 2. 데이터를 바꿉니다.
  count++; 
  
  // 3. [중요] 화면(DOM)을 직접 찾아서 억지로 바꿔 끼워야 합니다.
  // 개발자가 이걸 까먹으면 화면은 업데이트되지 않습니다. (버그 발생 원인 1순위)
  countDisplay.innerText = count; 
});

```

#### **✨ 리액트의 방식 (선언형)**

우리는 화면을 조작할 필요가 없습니다. 오직 **데이터(State)** 만 신경 쓰면 됩니다.

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // 상태(데이터) 정의

  return (
    <div>
      {/* 화면은 이 데이터(count)를 그대로 보여준다고 '선언'함 */}
      <span>{count}</span>
      
      {/* 버튼을 누르면 데이터만 바꾸면 됨. 화면 조작 코드 X */}
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}

```

#### **💡 코드 해설**

* **`useState(0)`** : `count`라는 변수를 만들고 초기값을 0으로 설정합니다. 리액트에서는 이를 **State(상태)** 라고 부릅니다.
* **`setCount`** : 이 함수를 통해 데이터를 바꾸면, 리액트는 "어? 데이터가 변했네?"라고 감지하고 화면을 **알아서** 다시 그립니다.
* **`document.getElementById` 삭제** : 화면을 직접 건드리는 코드가 사라졌습니다. 오직 데이터 관리에만 집중할 수 있습니다.

---

## 3. 리액트의 엔진: 가상 DOM (Virtual DOM)

여기서 의문이 생깁니다.

> "데이터가 바뀔 때마다 리액트가 화면을 알아서 고쳐준다고? 그럼 매번 화면 전체를 지웠다 다시 그리는 거 아니야? 엄청 느릴 텐데?"

맞습니다. 브라우저가 화면을 그리는 작업(DOM 조작)은 굉장히 비싼(느린) 작업입니다. 그래서 리액트는 **'가상 DOM(Virtual DOM)'** 이라는 천재적인 기술을 도입했습니다.

![리액트의 가상 DOM 동작 원리 (Diffing & Reconciliation)](/images/react/virtual-dom.png)


**[리액트의 처리 과정]**

1. **Render (가상 화면 그리기):** 데이터가 바뀌면, 메모리상에 있는 가상 연습장에 새로운 화면을 그립니다. (빛의 속도로 빠릅니다!)
2. **Diff (비교하기):** "이전 화면"과 "새 화면"을 비교해서 틀린 그림 찾기를 합니다.
3. **Commit (실제 반영하기):** 찾아낸 **'딱 그 부분'** 만 실제 브라우저 화면에 업데이트합니다.

이 과정 덕분에 우리는 편하게 코딩하면서도, 성능은 최적화된 앱을 만들 수 있는 것입니다.

---

## 4. 컴포넌트(Component): 레고 블록 조립하기

마지막으로 리액트의 강력한 무기는 **'컴포넌트 기반 개발'** 입니다.
우리가 앞으로 만들 **'Smart To-Do Planner'** 를 상상해 볼까요?

하나의 파일에 수천 줄의 코드를 때려 넣는 게 아닙니다. 화면을 의미 있는 단위로 쪼개서, 마치 레고 블록처럼 조립합니다.

![To-Do 앱 와이어프레임 구조도](/images/react/to-do-template.png)

### **🛠️ 코드로 미리보는 To-Do 앱 구조**

이 구조를 실제 리액트 코드로 짜면 이렇게 됩니다. HTML 태그처럼 생긴 것들이 바로 우리가 만든 컴포넌트들입니다.

```jsx
// App.jsx (메인 파일)

function App() {
  return (
    <div className="app-container">
      {/* 1. 헤더: 제목과 날짜 표시 */}
      <Header />
      
      {/* 2. 입력창: 할 일 입력 및 추가 */}
      <TodoInput />
      
      {/* 3. 리스트: 목록 보여주기 */}
      <TodoList>
        {/* 4. 아이템: 각각의 할 일들 (반복) */}
        <TodoItem text="리액트 공부하기" />
        <TodoItem text="블로그 글 쓰기" />
      </TodoList>
    </div>
  );
}

```

**[컴포넌트의 장점]**

1. **가독성:** `<div>` 지옥에서 벗어나, `<Header />`, `<TodoInput />`처럼 이름만 봐도 무엇인지 알 수 있습니다.
2. **재사용성:** `<TodoItem />` 하나만 잘 만들어두면, 할 일이 100개든 1000개든 똑같은 모양으로 찍어낼 수 있습니다.
3. **유지보수:** "삭제 버튼 디자인 좀 바꿔주세요"라는 요청이 오면, `<TodoItem />` 파일 하나만 고치면 모든 리스트에 반영됩니다.

---

## 🚀 마치며: 본격적인 여정을 시작해 볼까요?

오늘 내용을 요약해 볼까요?

1. 리액트는 **SPA** 를 만드는 도구입니다. (깜빡임 없는 부드러운 앱)
2. 리액트는 **선언형** 입니다. (과정을 일일이 명령하지 않고, 결과만 정의합니다.)
3. 리액트는 **가상 DOM** 을 사용해 알아서 빠르고 효율적으로 화면을 그립니다.
4. 리액트는 **컴포넌트** 단위로 쪼개서 개발하므로 유지보수가 쉽습니다.

이제 "왜 리액트인가"에 대한 의문이 풀리셨나요?
이론은 여기까지입니다. 다음 시간부터는 진짜 내 컴퓨터에 최신 개발 환경을 구축하고, **'Smart To-Do Planner'** 프로젝트를 생성해 보겠습니다.
